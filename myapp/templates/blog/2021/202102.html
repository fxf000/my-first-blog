{% load static %}

<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="01/2021">
  <meta name="keywords" content="programming, python, Algorithm, Machine Learning, Natural Language Processing">
  <link rel="stylesheet" type="text/css" href="{% static "./css/style.css"%}">

  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->

  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
</head>

<body onload="prettyPrint()">
  <div id="container">
  <header>
    <h1 id="logo"><a href="{% url 'index' %}"><img src="{% static './images/logo.png' %}" alt=""></a></h1>
    <iframe src="{% static './countdown/countdown.html' %}" frameBorder="0" scrolling="no"></iframe>
    <nav id="menubar">
    <ul>
    <li><a href="{% url 'record' %}">RECORD</a></li>
    <li><a href="{% url 'category' %}">CATEGORY</a></li>
    <li><a href="{% url 'about_me' %}">ABOUT ME</a></li>
    <li><a href="{% url 'link' %}">LINK</a></li>
    <li><a href="{% url 'index' %}#CONTACT">CONTACT</a></li>
    </ul>
    </nav>
  </header>
  <div id="contents">
    <h2>RECORD</h2>
    <h>
    <a href="{% url 'blog_202101' %}" class="no-underline" target="_blank" rel="noopener noreferrer">
      &#9655; Previous Month
    </a>
    </h>
    &emsp;
    <h id="02/2021">
      <b><font size=4 color="#000" face="Comic Sans MS">02/2021</font></b>
    </h>
    &emsp;
    <h>
    <a href="" class="no-underline" target="_blank" rel="noopener noreferrer">
      &#9655; Next Month
    </a>
    </h>
    <section id="02/08/2021">
      <hr width= 95%>
      <p>
        <b><font size="2" color="#000" face="Comic Sans MS">02/08/2021</font></b></br>
        I wrote a program about Union-Find.
        Union-Find is an algorithm that has a data structure in which
        data sets are disjoint sets and performs two convenient operators
        on the structure, Union and Find.
        The Union operator merges two sets,
        and the Find operator find which set a particular element belongs to.
        Then, I don't really understand the time complexity of Union-Find,
        but it maybe O(&alpha;(n)).
        &alpha;(n) is the extremely slow-growing
        <a href="https://en.wikipedia.org/wiki/Ackermann_function#Inverse">inverse Ackermann function</a>,
        is less than 5 for any practical input size n.
        I didn't go into the reason for the time complexity because
        it deviated from learning the basic of programming, which
        was original purpuse.
        </br>
        <p style="margin: -5px 20px -15px 40px;">
        <a class="no-underline" href="//judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_1_A" target="_blank" rel="noopener noreferrer">
          <b><font size="2" color="#000" face="Comic Sans MS" >Disjoint Set: Union Find Tree (DSL_1_A: Aize Online Judge)</font></b>
        </a>
        </p>
        <pre><code class="prettyprint linenums">
          from sys import stdin

          input = stdin.readline

          class DisjointSet(object):
              rank = []
              p = []
              def __init__(self,size):
                  for i in range(size):
                      self.makeSet(i)

              def makeSet(self,x):
                  DisjointSet.rank.insert(x,0)
                  DisjointSet.p.insert(x,x)

              def same(self,x,y):
                  return self.findSet(x) == self.findSet(y)

              def unite(self,x,y):
                  self.link(self.findSet(x),self.findSet(y))

              def link(self,x,y):
                  if DisjointSet.rank[x] > DisjointSet.rank[y]:
                      DisjointSet.p[y] = x
                  else:
                      DisjointSet.p[x] = y
                      if DisjointSet.rank[x] == DisjointSet.rank[y]:
                          DisjointSet.rank[y] += 1

              def findSet(self,x):
                  if x != DisjointSet.p[x]:
                      DisjointSet.p[x] = self.findSet(DisjointSet.p[x])
                  return DisjointSet.p[x]

          def main():
              n,q = map(int,input().split())

              ds = DisjointSet(n)

              for i in range(q):
                  com,x,y = input().split()
                  if com == "0":
                      ds.unite(int(x),int(y))
                  elif com == "1":
                      ans = ds.same(int(x),int(y))
                      if ans:
                          print(1)
                      else:
                          print(0)

          if __name__ == "__main__":
              main()
        </code></pre>
      </p>
        <p style="text-align:right; margin: -25px 0px 0px 0px;">
          <b><font size="2" color="#000" face="Comic Sans MS"  style="text-align:center">
          Category:
          <a class="no-underline" href="{% url 'category' %}#PROGRAMMING" target="_blank" rel="noopener noreferrer">
            Programming
          </a>
          </font></b>
        </p>
    </section>
    <section id="02/09/2021">
      <hr width= 95%>
      <p>
        <b><font size="2" color="#000" face="Comic Sans MS">02/09/2021</font></b></br>
        I studied about the convex optimizataion.
        For the time being, I put a file that summarizes convex sets and convex functions.
        </br>
        <a class="no-underline" href="{% static './MachineLearning/ConvexOptimization.pdf' %}" target="_blank" rel="noopener noreferrer">
          <b><font size="3" color="#000" face="cursive" >Convex optimization</font></b>
        </a>
      </p>
        <p style="text-align:right; margin: -25px 0px 0px 0px;">
          <b><font size="2" color="#000" face="Comic Sans MS"  style="text-align:center">
          Category:
          <a class="no-underline" href="{% url 'category' %}#ML" target="_blank" rel="noopener noreferrer">
            Machine Learning
          </a>
          </font></b>
        </p>
    </section>
    <section id="02/15/2021">
      <hr width= 95%>
      <p>
        <b><font size="2" color="#000" face="Comic Sans MS">02/15/2021</font></b></br>
        I wrote a program about
        <a href="https://en.wikipedia.org/wiki/K-d_tree">K-d tree</a>.
        K-d tree is a space-partitioning data structure for organizing points
        in a K-dimentional space.
        This time, I wrote the program of K = 2,
        so, the progrmam can find out if points exist in a region on a given 2D plane.
        In this program, the time complexity of building the tree is O (n(log<sub>2</sub>n)<sup>2</sup>)
        becasue the height of the tree is sorted logn times by O(nlog<sub>2</sub>n).
        And, it takes O (log<sub>2</sub>n) for the range seach.
        In general, it is known that the worst time complexity required for range search is
        O (K·n<sup>1-1/K</sup>) in in a K-dimensional K-d tree containing n nodes.
        Then, the excursion time of this program exceeded the limit,
        but I didn't know how to speed it up.
        </br>
        <p style="margin: -5px 20px -15px 40px;">
        <a class="no-underline" href="//judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_C" target="_blank" rel="noopener noreferrer">
          <b><font size="2" color="#000" face="Comic Sans MS" >Range Search (kD Tree) (DSL_2_C: Aize Online Judge)</font></b>
        </a>
        </p>
        <pre><code class="prettyprint linenums">
          from sys import stdin

          input = stdin.readline


          class Node(object):
              def __init__(self,location,l,r):
                  self.location = location
                  self.l = l
                  self.r = r


          class Point(object):
              def __init__(self,id,x,y):
                  self.id = id
                  self.x = x
                  self.y = y


          def make2DTree(l,r,depth):
              global np
              if not l < r:
                  return None
              mid = (l+r)//2
              t = np
              np += 1
              if depth%2 == 0:
                  Q = P[l:r]
                  Q = sorted(Q, key=lambda q: q.x)
                  P[l:r] = Q
              else:
                  Q = P[l:r]
                  Q = sorted(Q, key=lambda q: q.y)
                  P[l:r] = Q
              T[t].location = mid
              T[t].l = make2DTree(l,mid,depth+1)
              T[t].r = make2DTree(mid+1,r,depth+1)
              return t


          def find(v,sx,tx,sy,ty,depth,ans):
              x = P[T[v].location].x
              y = P[T[v].location].y
              if sx <= x and x <= tx and sy <= y and y <= ty:
                  ans.append([P[T[v].location].id,P[T[v].location]])
              if depth%2 == 0:
                  if T[v].l != None:
                      if sx <= x:
                          find(T[v].l,sx,tx,sy,ty,depth+1,ans)
                  if T[v].r != None:
                      if x <= tx:
                          find(T[v].r,sx,tx,sy,ty,depth+1,ans)
              else:
                  if T[v].l != None:
                      if sy <= y:
                          find(T[v].l,sx,tx,sy,ty,depth+1,ans)
                  if T[v].r != None:
                      if y <= ty:
                          find(T[v].r,sx,tx,sy,ty,depth+1,ans)


          n = int(input().rstrip())

          P = [Point(None,None,None) for _ in range(n)]
          T = [Node(None,None,None) for _ in range(n)]

          for i in range(n):
              x,y = map(int,input().split())
              P[i].id = i
              P[i].x  = x
              P[i].y = y

          np = 0
          root = make2DTree(0,n,0)

          q = int(input().rstrip())
          ans = []

          for j in range(q):
              sx,tx,sy,ty = map(int,input().split())
              ans.clear()
              find(root,sx,tx,sy,ty,0,ans)
              ans = sorted(ans,key=lambda a:a[0])
              for a in ans:
                  print(a[0])
              print("")

          #Time Limit Exceeded (Judge: 12/24	Python3	CPU: 06:00 sec	Memory: 217912 KB	Length: 1861 B)
        </code></pre>
      </p>
        <p style="text-align:right; margin: -25px 0px 0px 0px;">
          <b><font size="2" color="#000" face="Comic Sans MS"  style="text-align:center">
          Category:
          <a class="no-underline" href="{% url 'category' %}#PROGRAMMING" target="_blank" rel="noopener noreferrer">
            Programming
          </a>
          </font></b>
        </p>
    </section>
  </br>
    <h>
    <a href="{% url 'blog_202101' %}" class="no-underline" target="_blank" rel="noopener noreferrer">
      &#9655; Previous Month
    </a>
    </h>
    &emsp;
    <h>
      <b><font size=4 color="#000" face="Comic Sans MS">02/2021</font></b>
    </h>
    &emsp;
    <h>
    <a href="" class="no-underline" target="_blank" rel="noopener noreferrer">
      &#9655; Next Month
    </a>
    </h>
  </div>
    <hr width= 95%>
    <footer>
      <small>Copyright&copy; <a href="{% url 'index' %}">DAILY RECORD</a> All Rights Reserved.</small>
      <span class="pr">《<a href="http://template-party.com/" target="_blank">Web Design:Template-Party</a>》</span>
    </footer>
  </div>
</body>

</html>
